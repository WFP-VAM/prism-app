# WFP PRISM Frontend

This project is the front-end interface for the World Food Programme's [PRISM project](https://innovation.wfp.org/project/prism). It displays data and impact projections on a configurable map interface.

![](/docs/assets/prism_frontend.png)

## Functionalities

The new PRISM frontend is built as a static website to minimize cross dependencies and simplify deployments as much as possible. Currently, PRISM frontend provides the ability to:

- Load administrative boundaries as GeoJSON (`src/config/admin_boundaries.json`)
- Load admin level (vector) data as JSON, and link it to administrative boundaries
- Display WMS layers from Geoserver or Open Data Cube endpoints, with date selection capabilities
- Display point layers by applying symbology to numeric values associated with a geographic coordinate
- Display CSV tables in a left side panel

To chose which country to run PRISM for, you can set the environment variable `REACT_APP_COUNTRY`. The current default country is `mozambique`

## Configuration

The configuration is split into three files that you can find in `src/config`:

- 1. `prism.json`
- 2. `layers.json`
- 3. `tables.json`

Since many layers are common across multiple countries, we created shared configuration files that any deployment can access. Many of these layers are generated by WFP globally and made available through the Humanitarian Data Cube. You can find the layers and their associated styles / legends in `src/config/shared`:

- 1. `legends.json`
- 2. `layers.json`

### prism.json

This is the primary configuration file. You can define:

- Map settings (starting point, zoom, default boundary layers)
- The server endpoints
- Categories and their respective icons which are used to organize the top navigation
- Alerts flag (to specify whether to activate the alerts module)

For each category, you can define sub categories as "subcategory_name":
[layers], a list of layers from `layers.json`.

```
{
  "country": "Cambodia",
    "map": {
    "latitude": 12.058,
    "longitude": 105.281,
    "zoom": 6.49
  },
    "serversUrls": {
    "wms": [
      "https://geonode.wfp.org/geoserver/prism/wms/",
      "https://ows.earthobservation.vam.wfp.org/wms"
    ]
  },
  "alertFormActive": false,
  "hidePanel": false,
  "icons": {
    "vulnerability": "icon_vulnerable.png",
    "exposure": "icon_basemap.png",
    "hazards": "icon_climate.png",
    "risk": "icon_impact.png",
    "capacity": "icon_capacity.png",
    "tables": "icon_table.png"
  },
    "categories": {
      "hazards": {
        "floods" ....
```

#### Map settings

For each country, you will need to specify the starting point (lat, long) and zoom. In addition, you can also set

- maxBounds
- minZoom
- maxZoom

To find these attributes, we created a help mode that you can activate by setting the env `REACT_APP_SHOW_MAP_INFO=true`

#### Boundary layers

- Configuring multiple boundary layers
  If multiple boundary layers are configured in `layers.json` you can specify which should be displayed by default by defining `defaultDisplayBoundaries` as an array of boundaries.

  e.g.

  ```json
  {
    ...
    "defaultDisplayBoundaries": [
      "township_boundaries",
      "district_boundaries",
      "state_boundaries"
    ]
    ...
  }
  ```

In some cases, a boundary file may load without any issues but fail to provide correct results in an exposure analysis, or correctly render the 'Go To' feature. Troubleshooting this is challenging. It is recommended to use a validation tool on your boundary file before utilizing it in PRISM. https://geojsonlint.com/ works well for this purpose.

In addition, boundary files sometimes carry more precise coordinates than is neccessary which makes for a large data file. PRISM will alert you with a message in the browser if the precision is too high. You can run bash /frontend/scripts/truncate_precision.sh to fix this. The script will update any boundary file in the /frontend/public/data folder

#### PMTiles Support for Boundaries

PRISM supports the PMTiles format for administrative boundaries. PMTiles is an efficient single-file format for hosting vector tiles, which can significantly improve load times.

To use PMTiles for boundaries, configure your boundary layer in `layers.json`:

```json
{
  "admin_boundaries": {
    "type": "boundary",
    "format": "pmtiles", // Specify PMTiles format
    "path": "https://your-bucket.s3.region.amazonaws.com/path/to/boundaries.pmtiles", // HTTP path to file
    "zones_path": "s3://bucket-name/path-to.parquet", // S3 path to source data for analysis zonal stats
    "disableAnalysis": false, // Optionally hide from analysis option if performance concern
    "opacity": 0.8,
    "admin_code": "admin_code_field",
    "admin_level_names": ["ADMIN0", "ADMIN1", "ADMIN2"],
    "admin_level_local_names": ["admin0Name", "admin1Name", "admin2Name"],
    "styles": {
      "fill": {
        "fill-opacity": 0
      },
      "line": {
        "line-color": "gray",
        "line-width": 0.5,
        "line-opacity": 0.8
      }
    }
  }
}
```

#### Data Layers

Under `categories`, you can specify the menu structure and reference to any layer by ID that is defined under the country country specific or shared `layers.json`. You can also create groups that can be activated all at once, or selectively.

```
"categories": {
    "rainfall": {
      "forecasts": ["daily_rainfall_forecast", "dekad_rainfall_forecast"],
      "rainfall_amount": [
        {
          "group_title": "Rainfall Aggregate",
          "activate_all": false,
          "layers": [
            {
              "id": "rainfall_dekad",
              "label": "10-day",
              "main": true
            },
            {
              "id": "rainfall_agg_1month",
              "label": "1-month"
            },
            {
              "id": "rainfall_agg_3month",
              "label": "3-month"
            },
            {
              "id": "rainfall_agg_6month",
              "label": "6-month"
            },
            {
              "id": "rainfall_agg_9month",
              "label": "9-month"
            },
            {
              "id": "rainfall_agg_1year",
              "label": "1-year"
            }
          ]
        }
      ],
    }
}
```

### layers.json

In this file, we define the specific layer settings for data access, titles, and legends. You can define a new layer from scratch, or override a layer that exists in the `shared/layers.json`. In that case, you only need to specify the fields that need to be overriden. Similarly, legends can be predefined in `shared/legends.json` and simply reference to by id. The `"legend_text"` attribute describes the source of the data and can use Markdown syntax to render [links](example.com), _italics_, and **bold** text within our H5 typography.

There are 4 main types of layers.

#### raster

These layers are simply processed as raster images from a WMS server and are referred to as type 'wms'

```
"pasture_anomaly": {
    "title": "Pasture anomaly",
    "server_type": "wms",
    "server_layer": "ModisAnomaly",
    "server_uri": "https://mongolia.sibelius-datacube.org:5000/wms?layers=ModisAnomaly",
    "has_date": true,
    "date_interval": "days",
    "opacity": 0.3,
    "legend_text": "Converts  NDVI to pasture (kg/ha) values and divides the current period by the long term average to calculate pasture anomaly.",
    "legend": [
        { "value": "12000", "color": "#ff0000" },
        { "value": "14000", "color": "#ff5900" },
        { "value": "16000", "color": "#ff8400" },
        { "value": "18000", "color": "#ffce63" },
        { "value": "19000", "color": "#ffdd94" },
        { "value": "20000", "color": "#ffffbf" },
        { "value": "21000", "color": "#dee09f" },
        { "value": "22000", "color": "#bbbf7c" },
        { "value": "24000", "color": "#9da360" },
        { "value": "26000", "color": "#7e8745" },
        { "value": "28000", "color": "#5b6e00" }
    ]
}
```

#### admin level

These layers are referred to as `admin_level_data` in PRISM and represent a data value for a polygon. The layers are obtained by matching data from the `data_field` and `admin_code` fields of the `admin_level_data` layer with the administrative boundaries. The default admin boundary file will be used unless otherwise specifed in the `admin_level_data` configuration using the `boundary` attribute

```
  "improved_drinking_water": {
    "title": "Improved drinking water",
    "type": "admin_level_data",
    "path": "data/myanmar/nso/vulnerability-layers.json",
    "data_field": "improved_drinking_water",
    "admin_level": 3,
    "admin_code": "TS_PCODE",
    "opacity": 0.7,
    "legend": [
      { "label": "<20%", "value": 0, "color": "#a50f15" },
      { "label": "21 to 40%", "value": 21, "color": "#de2d26" },
      { "label": "41 to 60%", "value": 41, "color": "#fb6a4a" },
      { "label": "61 to 80%", "value": 61, "color": "#fcae91" },
      { "label": "81 to 100%", "value": 81, "color": "#fee5d9" }
    ],
    "legend_text": "Percent of households with improved source of drinking water. Source: Myanmar Population and Housing Census 2014, Department of Population, Ministry of Immigration and Population"
  }
```

#### point

These layers are referred to as `point_data` in PRISM and represent a data value for a given latitude and longitude coordinate. Point data layers visualize values specified as `measure_field` as points on a map based on the `geom_field` which expect a lat, long coordinate.

```
  "disaster_report": {
    "title": "Disaster impact report",
    "type": "point_data",
    "data": "https://prism-api.ovio.org/kobo/forms",
    "additional_query_params": {
      "form_name": "PRISM-KHM-Disaster-Report-v1",
      "datetime_field": "disaster_date",
      "geom_field": "location",
      "measure_field": "num_ppl_affected",
    }
    "opacity": 0.9,
    "legend_text": "Number of people affected",
    "legend": [
      {"value": "0", "color": "#909090"},
      {"value": "< 100", "color": "#ffeda0"},
      {"value": "100 - 500", "color": "#feb24c"},
      {"value": "500 or more", "color": "#f03b20"}
    ]
```

#### boundaries

Boundary layers are loaded by default when the application starts and typically show administrative boundaries and are defined as type `boundary`. Multiple boundary files can be configured in layers.json. Multiple boundary files can be used to create different styles for each boundary, or to toggle between admin_level_data layers which correspond to a separate geographic specification; for example to use one boundary file for district level data, and another boundary file for ecological data.

When more than one boundary is specified, an array of boundaries needs to also be set in `prism.json` using with the `defaultDisplayBoundaries` attribute.

```
{
  "state_admin_boundaries": {
    "type": "boundary",
    "path": "data/myanmar/mmr_admin1_boundaries.json",
    "opacity": 0.8,
    "admin_code": "ST_PCODE",
    "admin_level_names": ["ST"],
    "admin_level_local_names": ["mmr_polbnd"],
    "styles:": {
      "fill": {
        "fill-opacity": 0
      },
      "line": {
        "line-color": "gray",
        "line-width": 1.5,
        "line-opacity": 0.8
      }
    }
  },
  "district_admin_boundaries": {
    "type": "boundary",
    "path": "data/myanmar/mmr_admin2_boundaries.json",
    "opacity": 0.8,
    "admin_code": "DT_PCODE",
    "admin_level_names": ["ST", "DT"],
    "admin_level_local_names": ["DT_MMR4", "TS_MMR4"],
    "styles:": {
      "fill": {
        "fill-opacity": 0
      },
      "line": {
        "line-color": "gray",
        "line-width": 1,
        "line-opacity": 0.8
      }
    }
  },
  "admin_boundaries": {
    "type": "boundary",
    "path": "data/myanmar/admin_boundaries.json",
    "opacity": 0.8,
    "admin_code": "TS_PCODE",
    "admin_level_names": ["ST", "DT", "TS"],
    "admin_level_local_names": ["mmr_polbnd", "DT_MMR4", "TS_MMR4"],
    "styles:": {
      "fill": {
        "fill-opacity": 0
      },
      "line": {
        "line-color": "gray",
        "line-width": 0.5,
        "line-opacity": 0.8
      }
    }
  }
```

##### Accessing Boundary Data in Code

Boundary data is stored in a global cache. This ensures that boundary data is loaded once and shared across all map instances.

**In React Components:**

Use the `useBoundaryData` hook to access boundary data:

```typescript
import { useBoundaryData } from 'utils/useBoundaryData';
import { useMapState } from 'utils/useMapState';

function MyComponent() {
  const { maplibreMap } = useMapState();
  const { data, loading, error } = useBoundaryData('admin_boundaries', maplibreMap);
  
  if (loading) return <div>Loading boundaries...</div>;
  if (error) return <div>Error: {error}</div>;
  
  // data is a GeoJSON FeatureCollection
  return <div>{data.features.length} boundaries loaded</div>;
}
```

**In Redux Thunks or Async Functions:**

Use the `boundaryCache` directly:

```typescript
import { boundaryCache } from 'utils/boundary-cache';
import { getBoundaryLayerSingleton } from 'config/utils';

async function myAsyncFunction(dispatch) {
  const boundaryLayer = getBoundaryLayerSingleton();
  const boundaryData = await boundaryCache.getBoundaryData(
    boundaryLayer,
    dispatch,
    map, // optional, required for PMTiles format
  );
  
  if (!boundaryData) {
    throw new Error('Boundary data not loaded!');
  }
  
  // boundaryData is a GeoJSON FeatureCollection
  console.log(`Loaded ${boundaryData.features.length} features`);
}
```

#### impact

Impact layers are computed by combining a raster layer with a vector layer based on raster values bound by the zones of the vector layer. The impact layer computes zonal statistics for the raster, and based on a configured threshold, will display zones where the threshold has been exceeded.

```
"herd_pasture_impact": {
    "title": "Number of herder households exposed to severe pasture anomaly",
    "hazard_layer": "pasture_anomaly",
    "baseline_layer": "nsoHerders",
    "threshold": " <= 25000",
    "opacity": 0.3,
    "legend_text": "Number of herder households within ADMIN2 in an area where the median pasture anomaly is <= -50%",
    "legend": [
      { "value": "25", "color": "#ffeda0" },
      { "value": "30", "color": "#feb24c" },
      { "value": "35", "color": "#f03b20" }
    ]
}
```

### Additional layer content

#### Add Layer Contents

To display additional metadata about a layer, you can add a `content_path` attribute to any layer. The attribute expects a path to a `.md` or `.html` file that is stored in `public/data/${REACT_APP_COUNTRY}/filename.ext` directory. For example: `public/data/myanmar/contents.md`
The application will show an icon next to the layer in the legend if this attribute is configured, and will display the content in a modal window if the icon is clicked.

## Dashboards

Dashboards are customizable reports that combine maps, charts, tables, and text blocks in a flexible layout. They are configured in a `dashboards.json` file in your country's config folder (e.g., `src/config/mozambique/dashboards.json`).

### Dashboard Configuration Structure

Each dashboard is defined as an object with the following properties:

```json
{
  "title": "Dashboard Title",
  "path": "url-friendly-path",
  "isEditable": true,
  "firstColumn": [...],
  "secondColumn": [...],
  "thirdColumn": [...]
}
```

**Dashboard-level properties:**
- `title` (required): Display name of the dashboard
- `path` (optional): URL path for the dashboard. If omitted, it will be auto-generated from the title
- `isEditable` (optional): If `true`, users can edit the dashboard in the UI. Defaults to `false`
- `firstColumn` (required): Array of dashboard elements
- `secondColumn` (optional): Array of dashboard elements for the second column
- `thirdColumn` (optional): Array of dashboard elements for the third column

### Dashboard Elements

Each column contains an array of elements. There are four types of elements:

#### 1. MAP Element

Displays an interactive map with pre-selected layers.

```json
{
  "type": "MAP",
  "defaultDate": "2025-04-01",
  "mapPosition": "left",
  "minMapBounds": [31, -25, 40, -11],
  "title": "Temperature Anomaly Map",
  "legendVisible": true,
  "legendPosition": "right",
  "preSelectedMapLayers": [
    { "layerId": "lst_day_anomaly", "opacity": 0.7 },
    { "layerId": "rainfall_dekad", "opacity": 0.8 }
  ]
}
```

**Properties:**
- `type`: Must be `"MAP"`
- `preSelectedMapLayers` (required): Array of layer objects to display on the map
  - `layerId`: Layer ID from `layers.json`
  - `opacity` (optional): Layer opacity (0.0 to 1.0). Defaults to 1.0
- `defaultDate` (optional): Initial date for the map in `YYYY-MM-DD` format
- `mapPosition` (optional): `"left"` or `"right"` - used for side-by-side map comparison
- `minMapBounds` (optional): Map extent as `[west, south, east, north]`
- `title` (optional): Custom title for the map
- `legendVisible` (optional): Whether to show the legend. Defaults to `true`
- `legendPosition` (optional): Legend position - `"left"` or `"right"`. Defaults to `"right"`

#### 2. CHART Element

Displays time-series chart data for a WMS layer.

```json
{
  "type": "CHART",
  "startDate": "2025-01-01",
  "endDate": "2025-04-01",
  "layerId": "precip_blended_dekad",
  "adminUnitLevel": 1,
  "adminUnitId": 12345,
  "chartHeight": "tall"
}
```

**Properties:**
- `type`: Must be `"CHART"`
- `startDate` (required): Start date for chart data in `YYYY-MM-DD` format
- `layerId` (required): Layer ID from `layers.json` (must have `chartData` configured)
- `endDate` (optional): End date for chart data. If omitted, only `startDate` is used
- `adminUnitLevel` (optional): Administrative level (0, 1, 2, etc.) to aggregate data by
- `adminUnitId` (optional): Specific admin unit ID to filter chart data
- `chartHeight` (optional): Height of the chart. Options: `"tall"`, `"medium"`, `"short"`. Defaults to `"tall"`

#### 3. TABLE Element

Displays analysis results in a table format, combining a hazard layer with a baseline layer.

```json
{
  "type": "TABLE",
  "startDate": "2025-04-01",
  "hazardLayerId": "spi_blended_2m",
  "baselineLayerId": "admin1_boundaries",
  "threshold": { "below": -1.5, "above": 1.5 },
  "stat": "mean",
  "maxRows": 10,
  "addResultToMap": false,
  "sortColumn": "mean",
  "sortOrder": "desc"
}
```

**Properties:**
- `type`: Must be `"TABLE"`
- `startDate` (required): Date for analysis in `YYYY-MM-DD` format
- `hazardLayerId` (required): Hazard layer ID from `layers.json`
- `baselineLayerId` (required): Baseline layer ID (typically a boundary or admin level layer)
- `stat` (required): Aggregation statistic. Options:
  - `"mean"` - Average value
  - `"median"` - Median value
  - `"max"` - Maximum value
  - `"min"` - Minimum value
  - `"sum"` - Sum of values
  - `"intersect_percentage"` - Percent of area exposed
- `threshold` (optional): Object with `below` and/or `above` numeric values to filter results
- `maxRows` (optional): Maximum number of rows to display in the table. Defaults to `10`
- `addResultToMap` (optional): Whether to add the analysis result layer to the map. Set to `false` to show only the table without displaying the layer on the map. Defaults to `true`
- `sortColumn` (optional): Column to sort the table by. Can be `"name"` for the name column, or any statistic name like `"mean"`, `"max"`, `"min"`, etc. Defaults to `"name"`
- `sortOrder` (optional): Sort order for the table. Options are `"asc"` (ascending) or `"desc"` (descending). Defaults to `"asc"`

#### 4. TEXT Element

Displays formatted text content (supports markdown).

```json
{
  "type": "TEXT",
  "content": "# Analysis Summary\n\nThis dashboard shows precipitation patterns for April 2025.",
  "textUpdatedAt": "2025-03-01"
}
```

**Properties:**
- `type`: Must be `"TEXT"`
- `content` (required): Text content (supports markdown formatting)
- `textUpdatedAt` (optional): Date when content was last updated in `YYYY-MM-DD` format

### Dashboard Layout

Dashboards use a flexible column layout:
- **Columns with MAP elements** are wider (take up more space)
- **Columns without MAP elements** are narrower
- Elements within a column stack vertically
- Empty columns are not displayed

### Tips for Creating Dashboards

1. **Layer IDs**: All layer IDs (`layerId`, `layerId`, `hazardLayerId`, `baselineLayerId`) must exist in your `layers.json` file
2. **Date formats**: Always use `YYYY-MM-DD` format for dates
3. **Column balance**: Place MAP elements in their own column for better layout
4. **Chart layers**: Only layers with `chartData` configuration can be used in CHART elements
5. **Empty columns**: You can use empty arrays `[]` for columns you don't need

## Technical - Packages/Dependencies

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app), using the [Redux](https://redux.js.org/) and [Redux Toolkit](https://redux-toolkit.js.org/) template with TypeScript.

- **Styling & UI Library** Use [Material UI](https://material-ui.com/). Note that to use the [styles API](https://material-ui.com/styles/basics/) you can `import @material-ui/core/styles`.
- **Routing** Uses [React Router](https://reacttraining.com/react-router/web/guides/quick-start).
- **Monitoring** Uses [Sentry.io](https://sentry.io). To send monitoring info to Sentry, simply set the `Sentry` url by adding it as `REACT_APP_SENTRY_URL` in a `.env` file at the root folder.
- **State Management** Uses [Redux](https://redux.js.org/introduction/getting-started)
- **Testing** Uses [Jest](https://jestjs.io/)
- **Mapping** Uses [MapLibre](https://maplibre.org/maplibre-gl-js-docs/api/). The app supports Maptiler and Mapbox styles. To use Mapbox styles, you will need to create a token and add it as `REACT_APP_MAPBOX_TOKEN` in a `.env` file at the root folder. Then specify your style url using `REACT_APP_DEFAULT_STYLE`.
- **WFP authentication** Uses [msal](https://github.com/AzureAD/microsoft-authentication-library-for-js). You need to include within your .env file the variables `REACT_APP_OAUTH_CLIENT_ID`, `REACT_APP_OAUTH_AUTHORITY` and `REACT_APP_OAUTH_REDIRECT_URI`. Also, set the `WFPAuthRequired` flag within the country prism.json file

### Developing the frontend

The following commands should get you a local development instance of the frontend:

```
cd frontend
yarn clean
yarn install
yarn setup:common
REACT_APP_COUNTRY=cambodia yarn start
```

### Automated testing

Two sets of tests are available for the frontend:

- jest tests (unit tests) via `yarn test`
- end to end tests with [cypress](https://docs.cypress.io/app/get-started/why-cypress) via `yarn cypress open` (for
  interactive development) or `yarn cypress run` (to run the test suite, better suited for CI)

To write more end to end tests (e2e tests):

- start the frontend for the country you want to test `REACT_APP_COUNTRY=cambodia yarn start`
- open the cypress UI: `yarn cypress open`
  - in the electron app that opens, choose e2e tests and the browser to test with
  - in the controlled browser that opens, pick a file (either `all_countries.cy.ts` or the same country the frontend is
    running on) and start writing tests

The redux state tree is accesssible in cypress test via `window.store.getState()`.

### Available Scripts

In the project directory, you can run:

#### `yarn start`

Runs the app in the development mode.<br />
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.<br />
You will also see any lint errors in the console.

#### `yarn test`

Launches the test runner in the interactive watch mode.<br />
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

#### `yarn build`

Builds the app for production to the `build` folder.<br />
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br />
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

#### `yarn lint`

Runs `eslint` for all the source files. We use a custom Eslint configuration in `./eslintrc` along with [`prettier`](https://prettier.io/) (configured with `./.prettierrc`) to enforce consistency and code quality. If you would like eslint to try to automatically "fix" files if it can, run `yarn lint --fix`.

### Committing Code

By default, a pre-commit hook is defined to run linting tasks on all _staged_ code before allowing a commit. This occurs using the [lint-staged](https://github.com/okonet/lint-staged) package, and can be configured in `./package.json#lint-staged`. The precommit task can be run manually using `yarn precommit`.

### Creating pull requests and deploying to Firebase

By default, everytime a pull request is created, a CI/CD pipeline will run tests and deploy the code to a Firebase channel preview (http://staging-prism-frontend--prism-[pr number]-[random hash].web.app). To specify a country that the build will be run on, start your pull request title with `COUNTRY=[country name]`. For example: `COUNTRY=cambodia Add new config options`.

### Batch builds and test deploys (multi-country)

Use `frontend/scripts/country_build.sh` from the `frontend` folder:

- `yarn batch:build`: build zips for chosen countries into `frontend/builds/`
- `yarn deploy:tests`: deploy Firebase preview channels for chosen countries

Youâ€™ll be prompted for a list of countries (or select `all`). For deploys, ensure Firebase CLI is installed and authenticated.